# -*- coding: utf-8 -*-
"""test.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1r3qso5BOINQrf0sm-yHzDVnhsXRJRh84
"""

import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

#from mpl_toolkits.mplot3d import Axes3D
import datetime as dt
import plotly.graph_objects as go
import plotly.express as px
import plotly.figure_factory as ff

#Импорт набора данных
df = pd.read_csv("WindPowerProduction.csv")

df

df["Time stamp"] = pd.to_datetime(df["Time stamp"])
df

df.info()

#Создание нового столбца в наборе данных
df["Month"] = df["Time stamp"].dt.month
df_superset = df
df_superset["Day"] = df["Time stamp"].dt.day
df_superset.to_csv('WindPowerDay&Month.csv', index=False)

#Установка индекса на столбец Time stamp
df_day = df
df_day = df_day.set_index(df["Time stamp"])
df_day

#Группировка данных по месяцам для более простого и эффективного построения трендов.
grouped = df.groupby('Month').mean(numeric_only=True)
grouped

fig = px.line(df,
              x="Time stamp",
              y="Power Generated",
              labels = {'Time stamp':'Months of the year'},
              title = "Общая мощность, выработанная с января по декабрь")
fig.show()

fig = px.box(df,
        x='Month',
        y="Power Generated",
        color='Month',
        labels = {"x" : "Месяцы"},
        title="Выработка электроэнергии | Месячная статистика ")

fig.update_traces(width=0.5)
fig.show()

fig = px.scatter(df,
                 x="Wind Speed",
                 y="Power Generated",
                 title = "Power generated vs wind Speed")
fig.show()

fig = px.scatter(df,
                 x="Month",
                 y="Wind Speed",
                 title = "Power generated vs Wind Speed")
fig.show()

fig = px.box(df_day,
        x=df_day.index.day,
        y="Power Generated",
        color=df_day.index.day,
        labels = {"x" : "Дни"})

fig.update_traces(width=0.5)
fig.show()

fig = px.bar(grouped,
              x=grouped.index,
              y="Power Generated",
              labels = {'Month':'Месяцы'},
              color = "Power Generated",
              title="Выработка электроэнергии в месяц")
fig.update_traces(width=0.6)
fig.update_layout(barmode='group', xaxis_tickangle=-45)
fig.show()

fig = px.bar(grouped,
              x=grouped.index,
              y="Wind Speed",
              labels = {'Month':'Месяцы'},
              color = "Wind Speed",
              title="Скорость ветра в месяц")
fig.update_traces(width=0.6)
fig.update_layout(barmode='group', xaxis_tickangle=-45)
fig.show()

fig = px.box(df,
             y="Power Generated",
             title="Общая статистика выработки электроэнергии")

fig.show()

fig = px.box(df,
             y="Power Generated",
             title="Общая статистика скорости ветра")

fig.show()

df_corr = df.corr()
df_corr



x = list(df_corr.columns)
y = list(df_corr.index)
z = np.array(df_corr)

fig = ff.create_annotated_heatmap(x = x,
                                  y = y,
                                  z = z,
                                  annotation_text = np.around(z, decimals=2))
fig.show()

#Как видно из приведенной выше корреляционной матрицы, корреляция между мощностью и скоростью ветра очень высока. Еще 2 важных параметра – это давление (отвечает за ветер) и направление ветра.
fig = px.scatter_polar(df,
                       r="Wind Speed",
                       theta="Wind Direction")
fig.show()

fig = px.scatter_polar(df,
                       r="Power Generated",
                       theta="Wind Direction")
fig.show()

df.info()

# Split the dataset into two dataframes
#df = pd.read_csv("WindPower.csv")
#df['Time stamp'] = pd.to_datetime(df['Time stamp'])
#df["Month"] = df["Time stamp"].dt.month

df_1_to_11 = df[df['Month'].isin(range(1, 12))] # Select rows with months 1 to 11
df_12 = df[df['Month'] == 12] # Select rows with month 12

# Print the first 5 rows of each dataframe
df_1_to_11.to_csv("1to11.csv", index=False)
df_12.to_csv("to12.csv", index=False)
print(df_1_to_11.head())
print(df_12.head())

from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from sklearn.model_selection import train_test_split
from keras.models import Sequential
from keras.layers import LSTM, Dense
import tensorflow as tf
import xgboost as xgb


df_1_to_11 = df_1_to_11.drop('Time stamp', axis = 1).drop('Month', axis = 1)

# Split the dataset into training and test sets
#train_df, test_df = train_test_split(df_1_to_11, test_size=0.2, random_state=42)
train_df, test_df = train_test_split(df_1_to_11, test_size=0.2, random_state=42)

# Reshape the training and test data into a 3D array for LSTM input
X_train = train_df.drop("Power Generated", axis=1).values.reshape(-1, 1, 2)
X_test = test_df.drop("Power Generated", axis=1).values.reshape(-1, 1, 2)
y_train = train_df["Power Generated"].values.reshape(-1, 1)
y_test = test_df["Power Generated"].values.reshape(-1, 1)
#features = ["Wind Speed", "Wind Direction"]
#target = "Power Generated"

# Create XGBoost model
xgb_model = xgb.XGBRegressor(
    objective='reg:squarederror',
    learning_rate=0.02,
    max_depth=10,
    subsample=0.9,
    colsample_bytree=0.3,
    n_estimators=10000,
    random_state=42
)

# Create the LSTM model
model=Sequential()
model.add(LSTM(256,return_sequences=True,input_shape=(1, 2)))
model.add(LSTM(128,return_sequences=True))
model.add(LSTM(64))
model.add(Dense(1))
model.compile(loss='mean_squared_error',optimizer='adam')
model.summary()

# Train an XGBoost model
xgb_model.fit(train_df[features], train_df[target])

# Train the LSTM model
model.fit(X_train, y_train, epochs=100, verbose=100) #250

# xgb
preds = xgb_model.predict(test_df[features])
#df_12 = df_12.read_csv('to2.csv')
df_12 = df_12.drop('Time stamp', axis = 1)

preds = model.predict(X_test)

#df_12 = df_12.read_csv('to2.csv')

#df_12 = df_12.drop('Time stamp', axis = 1)

next_24_hours_X = df_12[["Wind Speed", "Wind Direction"]].values.reshape(-1, 1, 2)
# Make predictions using the model
next_24_hours_preds = model.predict(next_24_hours_X)

# Add the predicted values to the original dataframe
df_12["Power Generated"] = next_24_hours_preds.flatten()

# Write the updated data to the same excel file
df_12.to_csv("PredictData.csv", index=False)

data = pd.read_csv("to12.csv")
datapredict = pd.read_csv("PredictData.csv")
#Удаление нулей для подсчёта Percentage Mean Absolute Error
shape_str= str(data.shape)
leng = int(shape_str.replace('(', '').replace(')', '').replace(', 5', '').replace(', 6', ''))
for i in range(leng):
  if data['Power Generated'][i] == 0 or datapredict['Power Generated'][i] == 0:
    data = data.drop(index=[i])
    datapredict = datapredict.drop(index=[i])
data = data.reset_index(drop=True)
datapredict = datapredict.reset_index(drop=True)
data.to_excel('data.xlsx', index=False)
datapredict.to_excel('datapredict.xlsx', index=False)

mapedf = np.mean(np.abs((data["Power Generated"] - datapredict["Power Generated"]) / data["Power Generated"])) * 100
mape = np.mean(np.abs((y_test - preds) / y_test)) * 100
mae = mean_absolute_error(y_test, preds)
mse = mean_squared_error(y_test, preds)
rmse = np.sqrt(mse)
r2 = r2_score(y_test, preds)

print("Метрики работы модели:")
print("__________________________________________________________________")
print("Model Percentage Mean Absolute Error: ", mape)
print("Mean Absolute Error: ", mae)
print("Mean Squared Error: ", mse)
print("Root Mean Squared Error: ", rmse)
print("R^2: ", r2)
print("Percentage Mean Absolute Error: ", mapedf)
print("__________________________________________________________________")

import numpy as np
# Calculate the model performance metrics

#datapredict = datapredict.drop(index=data[data["System power generated | (kW)"] == 0].index)
#datapredict = datapredict.drop(index=datapredict[datapredict["System power generated | (kW)"] == 0].index)

mapedf = np.mean(np.abs((data["Power Generated"] - datapredict["Power Generated"]) / data["Power Generated"] )) * 100
mape = np.mean(np.abs((y_test - preds) / np.maximum(y_test, 1))) * 100  # replace division by zero with a value of zero
mae = mean_absolute_error(y_test, preds)
mse = mean_squared_error(y_test, preds)
rmse = np.sqrt(mse)
r2 = r2_score(y_test, preds)

# Print the model performance metrics
print("Metrics of model performance:")
print("__________________________________________________________________")
print("Model Percentage Mean Absolute Error: ", mape)
print("Mean Absolute Error: ", mae)
print("Mean Squared Error: ", mse)
print("Root Mean Squared Error: ", rmse)
print("R^2: ", r2)
print("Percentage Mean Absolute Error: ", mapedf)
print("__________________________________________________________________")

datapredict

data